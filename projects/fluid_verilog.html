<!DOCTYPE html>
<html>

<head>
    <title>Samuel's Blog</title>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"
        integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="/style.css">
    <script>
        $(function () {
            $(".header").load("/header.html");
            $(".footer").load("/footer.html");
        });
    </script>

</head>

<body>
    <div class="header"></div>

    <div class="row">
        <div class="box text">
            <h2>SystemVerilog Fluid Simulation</h2>
        </div>
    </div>

    <div class="row">
        <div class="column">
            <div class="box">
                <iframe src="https://drive.google.com/file/d/1CsYy8Zt6VRmXPiQ9usxuRLHgKSxmvhQv/preview" allow="autoplay"
                    class="video"></iframe>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="box text">
            <p>
                In this project, I implemented a basic Eulerian fluid simulation on the DE10-Lite FPGA using SystemVerilog. The simulation employed the Gauss-Seidel iterative method to enforce incompressibility and maintain continuity within the flow field. Advection was not yet incorporated in this version. The hardware design utilized three layers of dual-port block RAM to represent different stages of computation. The first memory layer stored the horizontal and vertical edge velocities for each grid cell, which were updated based on Gauss-Seidel iterations and real-time cursor input. The second layer computed and stored the magnitude and direction vectors of the flow using these velocities. The third layer functioned as a framebuffer, storing pixel data for VGA output. Arrow rendering was achieved by projecting each pixel onto the local velocity vector and conditionally coloring it based on the distance from the vector, effectively visualizing flow direction. While not the most optimized rendering method, this approach provided an intuitive and visually clear representation. The full Quartus project, SystemVerilog source code, and testbenches are available in the <a
                href="https://github.com/SamuelHo10/Verilog-Fluid-Simulation">project repository</a>.
            </p>
        </div>
    </div>
    <div class="footer"></div>

</body>

</html>